<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Color Converter | Convert Between HEX, RGB, HSL, CMYK, color format converter | Tool-ify</title>
    <meta name="description" content="Convert colors between HEX, RGB, HSL, and CMYK formats online for free. Easy to use color converter with live preview and color picker.">
    <meta name="keywords" content="color converter, hex to rgb, rgb to hex, hsl converter, cmyk converter, color format, color code, web colors">
    <link rel="canonical" href="https://tool-ify.com/tools/color-converter.html">
    <link rel="stylesheet" href="../css/style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="icon" href="/favicon.svg" type="image/svg+xml">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-RDHJFH4L0J"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
        gtag('config', 'G-RDHJFH4L0J');
    </script>
    <!-- Structured Data for SEO -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Color Converter",
        "url": "https://tool-ify.com/tools/color-converter.html",
        "description": "Convert between HEX, RGB, HSL, CMYK color formats",
        "applicationCategory": "UtilityApplication",
        "offers": {
            "@type": "Offer",
            "price": "0"
        }
    }
    </script>
    <style>
        /* 修复布局，确保页面至少占满整个视口高度 */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
        }
        
        body {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        
        main {
            flex: 1 0 auto;
        }
        
        footer {
            flex-shrink: 0;
            margin-top: 20px;
        }
        
        .tool-container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .converter-container {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin-bottom: 30px;
        }
        
        @media (min-width: 768px) {
            .converter-container {
                flex-direction: row;
            }
            
            .color-inputs {
                flex: 1;
            }
            
            .color-preview {
                flex: 1;
            }
        }
        
        .color-inputs {
            background-color: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            padding: 20px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        .input-label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
        }
        
        .color-input {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 14px;
        }
        
        .color-picker-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 20px;
        }
        
        .color-picker {
            width: 40px;
            height: 40px;
            padding: 0;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            overflow: hidden;
        }
        
        .color-picker-label {
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .color-preview {
            background-color: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            padding: 20px;
        }
        
        .preview-box {
            width: 100%;
            height: 200px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: background-color 0.3s ease;
        }
        
        .color-info {
            background-color: var(--bg-color);
            border-radius: 6px;
            padding: 15px;
            border: 1px solid var(--border-color);
        }
        
        .color-value {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .color-value:last-child {
            margin-bottom: 0;
        }
        
        .copy-btn {
            background: none;
            border: none;
            color: var(--accent-color);
            cursor: pointer;
            padding: 2px 6px;
            font-size: 12px;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        
        .copy-btn:hover {
            text-decoration: underline;
        }
        
        .color-name {
            margin-top: 10px;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .color-schemes {
            background-color: var(--bg-secondary);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            padding: 20px;
            margin-bottom: 30px;
        }
        
        .schemes-title {
            margin-top: 0;
            margin-bottom: 20px;
            font-size: 18px;
        }
        
        .scheme-tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 20px;
        }
        
        .scheme-tab {
            padding: 8px 16px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            margin-right: 10px;
            font-size: 14px;
            color: var(--text-secondary);
        }
        
        .scheme-tab.active {
            color: var(--accent-color);
            border-bottom: 2px solid var(--accent-color);
        }
        
        .scheme-colors {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .scheme-color {
            width: 60px;
            height: 60px;
            border-radius: 4px;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: transform 0.2s ease;
            position: relative;
        }
        
        .scheme-color:hover {
            transform: scale(1.05);
        }
        
        .scheme-color-tooltip {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background-color: var(--bg-color);
            color: var(--text-color);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            z-index: 10;
        }
        
        .scheme-color:hover .scheme-color-tooltip {
            opacity: 1;
            visibility: visible;
        }
        
        .back-link {
            display: inline-flex;
            align-items: center;
            color: var(--text-secondary);
            text-decoration: none;
            margin-bottom: 20px;
            font-size: 14px;
        }
        
        .back-link:hover {
            color: var(--accent-color);
        }
        
        .back-link i {
            margin-right: 6px;
        }
        
        .notification {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 4px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transform: translateY(100px);
            opacity: 0;
            transition: transform 0.3s ease, opacity 0.3s ease;
            z-index: 1000;
        }
        
        .notification.success {
            background-color: var(--accent-color);
            color: white;
        }
        
        .notification.error {
            background-color: #e53e3e;
            color: white;
        }
        
        .notification.show {
            transform: translateY(0);
            opacity: 1;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <div class="logo">
                <a href="../index.html">Tool-ify</a>
            </div>
            <div class="header-actions">
                <div class="language-selector">
                    <button class="language-btn" id="language-toggle">
                        <i class="fas fa-globe"></i>
                        <span id="current-language">English</span>
                    </button>
                    <div class="language-dropdown" id="language-dropdown">
                        <a href="#" data-lang="en">English</a>
                        <a href="#" data-lang="zh">中文</a>
                        <a href="#" data-lang="es">Español</a>
                    </div>
                </div>
                <button class="theme-toggle" id="theme-toggle">
                    <i class="fas fa-moon"></i>
                </button>
            </div>
        </div>
    </header>

    <main>
        <div class="container">
            <div class="tool-container">
                <a href="../index.html" class="back-link">
                    <i class="fas fa-arrow-left"></i> <span id="back-text">Back to tools</span>
                </a>
                
                <h1 id="tool-title">Color Converter</h1>
                <p id="tool-description">Convert between HEX, RGB, HSL, CMYK color formats</p>
                
                <div class="converter-container">
                    <div class="color-inputs">
                        <div class="color-picker-container">
                            <input type="color" id="color-picker" class="color-picker" value="#4285f4">
                            <span class="color-picker-label" id="color-picker-label">Pick a color</span>
                        </div>
                        
                        <div class="input-group">
                            <label class="input-label" for="hex-input" id="hex-label">HEX</label>
                            <input type="text" id="hex-input" class="color-input" placeholder="#RRGGBB" value="#4285f4">
                        </div>
                        
                        <div class="input-group">
                            <label class="input-label" for="rgb-input" id="rgb-label">RGB</label>
                            <input type="text" id="rgb-input" class="color-input" placeholder="rgb(R, G, B)" value="rgb(66, 133, 244)">
                        </div>
                        
                        <div class="input-group">
                            <label class="input-label" for="hsl-input" id="hsl-label">HSL</label>
                            <input type="text" id="hsl-input" class="color-input" placeholder="hsl(H, S%, L%)" value="hsl(217, 89%, 61%)">
                        </div>
                        
                        <div class="input-group">
                            <label class="input-label" for="cmyk-input" id="cmyk-label">CMYK</label>
                            <input type="text" id="cmyk-input" class="color-input" placeholder="cmyk(C%, M%, Y%, K%)" value="cmyk(73%, 45%, 0%, 4%)">
                        </div>
                    </div>
                    
                    <div class="color-preview">
                        <div class="preview-box" id="preview-box" style="background-color: #4285f4;"></div>
                        
                        <div class="color-info">
                            <div class="color-value">
                                <span id="hex-value">#4285f4</span>
                                <button class="copy-btn" data-clipboard-target="#hex-value" id="copy-hex-btn">
                                    <i class="fas fa-copy"></i> <span id="copy-text-1">Copy</span>
                                </button>
                            </div>
                            
                            <div class="color-value">
                                <span id="rgb-value">rgb(66, 133, 244)</span>
                                <button class="copy-btn" data-clipboard-target="#rgb-value" id="copy-rgb-btn">
                                    <i class="fas fa-copy"></i> <span id="copy-text-2">Copy</span>
                                </button>
                            </div>
                            
                            <div class="color-value">
                                <span id="hsl-value">hsl(217, 89%, 61%)</span>
                                <button class="copy-btn" data-clipboard-target="#hsl-value" id="copy-hsl-btn">
                                    <i class="fas fa-copy"></i> <span id="copy-text-3">Copy</span>
                                </button>
                            </div>
                            
                            <div class="color-value">
                                <span id="cmyk-value">cmyk(73%, 45%, 0%, 4%)</span>
                                <button class="copy-btn" data-clipboard-target="#cmyk-value" id="copy-cmyk-btn">
                                    <i class="fas fa-copy"></i> <span id="copy-text-4">Copy</span>
                                </button>
                            </div>
                        </div>
                        
                        <div class="color-name" id="color-name"></div>
                    </div>
                </div>
                
                <div class="color-schemes">
                    <h2 class="schemes-title" id="schemes-title">Color Schemes</h2>
                    
                    <div class="scheme-tabs">
                        <div class="scheme-tab active" data-scheme="monochromatic" id="monochromatic-tab">Monochromatic</div>
                        <div class="scheme-tab" data-scheme="complementary" id="complementary-tab">Complementary</div>
                        <div class="scheme-tab" data-scheme="analogous" id="analogous-tab">Analogous</div>
                        <div class="scheme-tab" data-scheme="triadic" id="triadic-tab">Triadic</div>
                    </div>
                    
                    <div class="scheme-colors" id="scheme-colors">
                        <!-- Color scheme will be generated here -->
                    </div>
                </div>
            </div>
        </div>
    </main>

    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <p>&copy; 2023 Tool-ify.com - All tools are free and work in your browser</p>
                </div>
                <div class="footer-links">
                    <a href="../contact.html">Contact</a>
                    <a href="../privacy.html">Privacy Policy</a>
                    <a href="../terms.html">Terms of Use</a>
                </div>
            </div>
        </div>
    </footer>
    
    <div class="notification" id="notification">Notification message</div>

    <script src="../js/main.js"></script>
    <script src="../js/localization.js"></script>
    <script src="../js/loading.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // 等待翻译加载完成
            function applyTranslations() {
                if (window.translations) {
                    // 更新页面文本
                    updateTexts();
                    
                    // 更新占位符文本
                    updatePlaceholders();
                    
                    // 更新动态文本，如通知消息
                    setupNotifications();
                } else {
                    // 如果翻译尚未加载，等待100毫秒后再次尝试
                    setTimeout(applyTranslations, 100);
                }
            }
            
            // 开始尝试应用翻译
            applyTranslations();
            
            // 更新页面文本
            function updateTexts() {
                if (window.translations) {
                    // 更新返回链接
                    if (window.translations.footer && window.translations.footer.back) {
                        const backText = document.getElementById('back-text');
                        if (backText) {
                            backText.textContent = window.translations.footer.back;
                        }
                    }
                    
                    // 更新UI文本
                    if (window.translations.ui) {
                        const textMappings = {
                            'color-picker-label': 'pick_a_color',
                            'hex-label': 'hex',
                            'rgb-label': 'rgb',
                            'hsl-label': 'hsl',
                            'cmyk-label': 'cmyk',
                            'copy-text-1': 'copy',
                            'copy-text-2': 'copy',
                            'copy-text-3': 'copy',
                            'copy-text-4': 'copy',
                            'schemes-title': 'color_schemes',
                            'monochromatic-tab': 'monochromatic',
                            'complementary-tab': 'complementary',
                            'analogous-tab': 'analogous',
                            'triadic-tab': 'triadic'
                        };
                        
                        for (const [id, key] of Object.entries(textMappings)) {
                            if (window.translations.ui[key]) {
                                const element = document.getElementById(id);
                                if (element) {
                                    element.textContent = window.translations.ui[key];
                                }
                            }
                        }
                    }
                }
            }
            
            // 更新占位符文本
            function updatePlaceholders() {
                if (window.translations && window.translations.placeholders) {
                    const placeholderMappings = {
                        'hex-input': 'hex_placeholder',
                        'rgb-input': 'rgb_placeholder',
                        'hsl-input': 'hsl_placeholder',
                        'cmyk-input': 'cmyk_placeholder'
                    };
                    
                    for (const [id, key] of Object.entries(placeholderMappings)) {
                        if (window.translations.placeholders[key]) {
                            const element = document.getElementById(id);
                            if (element) {
                                element.placeholder = window.translations.placeholders[key];
                            }
                        }
                    }
                }
            }
            
            // 设置通知消息翻译
            function setupNotifications() {
                // 保存原始的showNotification函数引用
                const originalShowNotification = showNotification;
                
                // 重新定义showNotification函数
                window.showNotification = function(message, type) {
                    // 尝试获取翻译
                    const translatedMessage = getTranslatedText(message, message);
                    // 调用原始函数，但使用翻译后的消息
                    originalShowNotification(translatedMessage, type);
                };
            }
            
            // 获取翻译文本
            function getTranslatedText(key, defaultText) {
                if (window.translations && window.translations.notifications) {
                    // 尝试找到完全匹配的键
                    if (window.translations.notifications[key]) {
                        return window.translations.notifications[key];
                    }
                    
                    // 如果没有完全匹配，尝试根据消息内容查找相似的键
                    if (key === 'Copied to clipboard') {
                        return window.translations.notifications.copied_clipboard || defaultText;
                    }
                    
                    if (key === 'Failed to copy') {
                        return window.translations.notifications.copy_failed || defaultText;
                    }
                }
                
                return defaultText;
            }

            // DOM elements
            const colorPicker = document.getElementById('color-picker');
            const hexInput = document.getElementById('hex-input');
            const rgbInput = document.getElementById('rgb-input');
            const hslInput = document.getElementById('hsl-input');
            const cmykInput = document.getElementById('cmyk-input');
            const previewBox = document.getElementById('preview-box');
            const hexValue = document.getElementById('hex-value');
            const rgbValue = document.getElementById('rgb-value');
            const hslValue = document.getElementById('hsl-value');
            const cmykValue = document.getElementById('cmyk-value');
            const colorName = document.getElementById('color-name');
            const schemeTabs = document.querySelectorAll('.scheme-tab');
            const schemeColors = document.getElementById('scheme-colors');
            const copyButtons = document.querySelectorAll('.copy-btn');
            const notification = document.getElementById('notification');
            
            // Initialize with default color
            updateAllFromHex('#4285f4');
            
            // Color picker change
            colorPicker.addEventListener('input', function() {
                updateAllFromHex(this.value);
            });
            
            // Input field change events
            hexInput.addEventListener('input', function() {
                const hex = this.value;
                if (isValidHex(hex)) {
                    updateAllFromHex(hex);
                }
            });
            
            rgbInput.addEventListener('input', function() {
                const rgb = this.value;
                if (isValidRgb(rgb)) {
                    const values = parseRgb(rgb);
                    const hex = rgbToHex(values.r, values.g, values.b);
                    updateAllFromHex(hex);
                }
            });
            
            hslInput.addEventListener('input', function() {
                const hsl = this.value;
                if (isValidHsl(hsl)) {
                    const values = parseHsl(hsl);
                    const rgb = hslToRgb(values.h, values.s, values.l);
                    const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
                    updateAllFromHex(hex);
                }
            });
            
            cmykInput.addEventListener('input', function() {
                const cmyk = this.value;
                if (isValidCmyk(cmyk)) {
                    const values = parseCmyk(cmyk);
                    const rgb = cmykToRgb(values.c, values.m, values.y, values.k);
                    const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
                    updateAllFromHex(hex);
                }
            });
            
            // Copy buttons
            copyButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    const targetId = this.getAttribute('data-clipboard-target');
                    const targetElement = document.querySelector(targetId);
                    const textToCopy = targetElement.textContent;
                    
                    // 使用Loading组件，让UI保持响应性
                    Loading.show();
                    
                    setTimeout(() => {
                        navigator.clipboard.writeText(textToCopy)
                            .then(() => {
                                Loading.hide();
                                showNotification('Copied to clipboard', 'success');
                            })
                            .catch(err => {
                                Loading.hide();
                                showNotification('Failed to copy', 'error');
                            });
                    }, 10);
                });
            });
            
            // Scheme tabs
            schemeTabs.forEach(tab => {
                tab.addEventListener('click', function() {
                    schemeTabs.forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    
                    const schemeType = this.getAttribute('data-scheme');
                    const currentHex = hexInput.value;
                    
                    generateColorScheme(currentHex, schemeType);
                });
            });
            
            // Generate initial color scheme
            generateColorScheme('#4285f4', 'monochromatic');
            
            // Click on scheme color to set as main color
            schemeColors.addEventListener('click', function(e) {
                const target = e.target;
                if (target.classList.contains('scheme-color')) {
                    const color = target.style.backgroundColor;
                    const rgb = parseRgb(color);
                    const hex = rgbToHex(rgb.r, rgb.g, rgb.b);
                    updateAllFromHex(hex);
                }
            });
            
            // Main function to update all color formats from HEX
            function updateAllFromHex(hex) {
                // Clean the hex if needed
                hex = cleanHex(hex);
                
                // Update color picker
                colorPicker.value = hex;
                
                // Convert to other formats
                const rgb = hexToRgb(hex);
                const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
                const cmyk = rgbToCmyk(rgb.r, rgb.g, rgb.b);
                
                // Format values for display
                const rgbString = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
                const hslString = `hsl(${Math.round(hsl.h)}, ${Math.round(hsl.s)}%, ${Math.round(hsl.l)}%)`;
                const cmykString = `cmyk(${Math.round(cmyk.c)}%, ${Math.round(cmyk.m)}%, ${Math.round(cmyk.y)}%, ${Math.round(cmyk.k)}%)`;
                
                // Update input fields
                hexInput.value = hex;
                rgbInput.value = rgbString;
                hslInput.value = hslString;
                cmykInput.value = cmykString;
                
                // Update preview
                previewBox.style.backgroundColor = hex;
                
                // Update output values
                hexValue.textContent = hex;
                rgbValue.textContent = rgbString;
                hslValue.textContent = hslString;
                cmykValue.textContent = cmykString;
                
                // Update color name
                colorName.textContent = findColorName(hex);
                
                // Update color scheme
                const activeScheme = document.querySelector('.scheme-tab.active').getAttribute('data-scheme');
                generateColorScheme(hex, activeScheme);
            }
            
            // Generate color scheme
            function generateColorScheme(hex, type) {
                const rgb = hexToRgb(hex);
                const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
                
                // 对于复杂的配色方案计算，使用Loading组件
                if (type === 'triadic' || type === 'analogous') {
                    Loading.show();
                    setTimeout(() => {
                        generateSchemeColors(hex, type, rgb, hsl);
                        Loading.hide();
                    }, 10);
                } else {
                    generateSchemeColors(hex, type, rgb, hsl);
                }
            }
            
            // 实际生成配色方案的函数
            function generateSchemeColors(hex, type, rgb, hsl) {
                let colors = [];
                
                switch (type) {
                    case 'monochromatic':
                        // Generate different lightness values
                        for (let i = 0; i < 5; i++) {
                            const l = Math.max(0, Math.min(100, hsl.l - 20 + i * 10));
                            const newRgb = hslToRgb(hsl.h, hsl.s, l);
                            colors.push(rgbToHex(newRgb.r, newRgb.g, newRgb.b));
                        }
                        break;
                        
                    case 'complementary':
                        // Add the original color
                        colors.push(hex);
                        
                        // Add a few shades of the original
                        for (let i = 1; i < 3; i++) {
                            const l = Math.max(0, Math.min(100, hsl.l - 15 + i * 15));
                            const newRgb = hslToRgb(hsl.h, hsl.s, l);
                            colors.push(rgbToHex(newRgb.r, newRgb.g, newRgb.b));
                        }
                        
                        // Add the complementary color (opposite on the color wheel)
                        const complementaryH = (hsl.h + 180) % 360;
                        const complementaryRgb = hslToRgb(complementaryH, hsl.s, hsl.l);
                        colors.push(rgbToHex(complementaryRgb.r, complementaryRgb.g, complementaryRgb.b));
                        
                        // Add a shade of the complementary
                        const compLight = hslToRgb(complementaryH, hsl.s, Math.min(100, hsl.l + 15));
                        colors.push(rgbToHex(compLight.r, compLight.g, compLight.b));
                        break;
                        
                    case 'analogous':
                        // Add colors with hues that are +/- 30 degrees from the original
                        for (let i = -2; i <= 2; i++) {
                            const h = (hsl.h + i * 30 + 360) % 360;
                            const newRgb = hslToRgb(h, hsl.s, hsl.l);
                            colors.push(rgbToHex(newRgb.r, newRgb.g, newRgb.b));
                        }
                        break;
                        
                    case 'triadic':
                        // Add three colors equally spaced around the color wheel
                        for (let i = 0; i < 3; i++) {
                            const h = (hsl.h + i * 120) % 360;
                            const newRgb = hslToRgb(h, hsl.s, hsl.l);
                            colors.push(rgbToHex(newRgb.r, newRgb.g, newRgb.b));
                            
                            // Add a variant of each
                            const variantRgb = hslToRgb(h, Math.max(0, hsl.s - 20), Math.min(100, hsl.l + 15));
                            colors.push(rgbToHex(variantRgb.r, variantRgb.g, variantRgb.b));
                        }
                        break;
                }
                
                // Render the colors
                schemeColors.innerHTML = '';
                colors.forEach(color => {
                    const colorDiv = document.createElement('div');
                    colorDiv.className = 'scheme-color';
                    colorDiv.style.backgroundColor = color;
                    
                    const tooltip = document.createElement('div');
                    tooltip.className = 'scheme-color-tooltip';
                    tooltip.textContent = color;
                    
                    colorDiv.appendChild(tooltip);
                    schemeColors.appendChild(colorDiv);
                });
            }
            
            // Color format validators
            function isValidHex(hex) {
                return /^#?([0-9A-F]{3}){1,2}$/i.test(hex);
            }
            
            function isValidRgb(rgb) {
                return /^rgb\(\s*\d+\s*,\s*\d+\s*,\s*\d+\s*\)$/.test(rgb);
            }
            
            function isValidHsl(hsl) {
                return /^hsl\(\s*\d+\s*,\s*\d+%?\s*,\s*\d+%?\s*\)$/.test(hsl);
            }
            
            function isValidCmyk(cmyk) {
                return /^cmyk\(\s*\d+%?\s*,\s*\d+%?\s*,\s*\d+%?\s*,\s*\d+%?\s*\)$/.test(cmyk);
            }
            
            // Parsers
            function cleanHex(hex) {
                // Ensure hex has the # prefix
                if (!hex.startsWith('#')) {
                    hex = '#' + hex;
                }
                
                // Convert shorthand hex (#RGB) to full form (#RRGGBB)
                if (hex.length === 4) {
                    hex = '#' + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];
                }
                
                return hex;
            }
            
            function parseRgb(rgb) {
                const matches = rgb.match(/\d+/g);
                if (matches && matches.length >= 3) {
                    return {
                        r: parseInt(matches[0]),
                        g: parseInt(matches[1]),
                        b: parseInt(matches[2])
                    };
                }
                return { r: 0, g: 0, b: 0 };
            }
            
            function parseHsl(hsl) {
                const matches = hsl.match(/\d+/g);
                if (matches && matches.length >= 3) {
                    return {
                        h: parseInt(matches[0]),
                        s: parseInt(matches[1]),
                        l: parseInt(matches[2])
                    };
                }
                return { h: 0, s: 0, l: 0 };
            }
            
            function parseCmyk(cmyk) {
                const matches = cmyk.match(/\d+/g);
                if (matches && matches.length >= 4) {
                    return {
                        c: parseInt(matches[0]),
                        m: parseInt(matches[1]),
                        y: parseInt(matches[2]),
                        k: parseInt(matches[3])
                    };
                }
                return { c: 0, m: 0, y: 0, k: 0 };
            }
            
            // Conversion functions
            function hexToRgb(hex) {
                hex = hex.replace(/^#/, '');
                let bigint = parseInt(hex, 16);
                let r = (bigint >> 16) & 255;
                let g = (bigint >> 8) & 255;
                let b = bigint & 255;
                
                return { r, g, b };
            }
            
            function rgbToHex(r, g, b) {
                return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
            }
            
            function rgbToHsl(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;
                
                const max = Math.max(r, g, b);
                const min = Math.min(r, g, b);
                let h, s, l = (max + min) / 2;
                
                if (max === min) {
                    h = s = 0; // achromatic
                } else {
                    const d = max - min;
                    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    
                    switch (max) {
                        case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                        case g: h = (b - r) / d + 2; break;
                        case b: h = (r - g) / d + 4; break;
                    }
                    
                    h /= 6;
                }
                
                return {
                    h: Math.round(h * 360),
                    s: Math.round(s * 100),
                    l: Math.round(l * 100)
                };
            }
            
            function hslToRgb(h, s, l) {
                h /= 360;
                s /= 100;
                l /= 100;
                
                let r, g, b;
                
                if (s === 0) {
                    r = g = b = l; // achromatic
                } else {
                    const hue2rgb = (p, q, t) => {
                        if (t < 0) t += 1;
                        if (t > 1) t -= 1;
                        if (t < 1/6) return p + (q - p) * 6 * t;
                        if (t < 1/2) return q;
                        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
                        return p;
                    };
                    
                    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
                    const p = 2 * l - q;
                    
                    r = hue2rgb(p, q, h + 1/3);
                    g = hue2rgb(p, q, h);
                    b = hue2rgb(p, q, h - 1/3);
                }
                
                return {
                    r: Math.round(r * 255),
                    g: Math.round(g * 255),
                    b: Math.round(b * 255)
                };
            }
            
            function rgbToCmyk(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;
                
                const k = 1 - Math.max(r, g, b);
                const c = (1 - r - k) / (1 - k) || 0;
                const m = (1 - g - k) / (1 - k) || 0;
                const y = (1 - b - k) / (1 - k) || 0;
                
                return {
                    c: Math.round(c * 100),
                    m: Math.round(m * 100),
                    y: Math.round(y * 100),
                    k: Math.round(k * 100)
                };
            }
            
            function cmykToRgb(c, m, y, k) {
                c /= 100;
                m /= 100;
                y /= 100;
                k /= 100;
                
                const r = 255 * (1 - c) * (1 - k);
                const g = 255 * (1 - m) * (1 - k);
                const b = 255 * (1 - y) * (1 - k);
                
                return {
                    r: Math.round(r),
                    g: Math.round(g),
                    b: Math.round(b)
                };
            }
            
            // Find nearest color name
            function findColorName(hex) {
                // Basic color map - in a real app, this could be much more comprehensive
                const colorMap = {
                    '#FF0000': 'Red',
                    '#00FF00': 'Green',
                    '#0000FF': 'Blue',
                    '#FFFF00': 'Yellow',
                    '#FF00FF': 'Magenta',
                    '#00FFFF': 'Cyan',
                    '#000000': 'Black',
                    '#FFFFFF': 'White',
                    '#808080': 'Gray',
                    '#FFA500': 'Orange',
                    '#800080': 'Purple',
                    '#008000': 'Dark Green',
                    '#800000': 'Maroon',
                    '#000080': 'Navy Blue',
                    '#4285F4': 'Google Blue',
                    '#DB4437': 'Google Red',
                    '#F4B400': 'Google Yellow',
                    '#0F9D58': 'Google Green'
                };
                
                // Check if exact match
                if (colorMap[hex.toUpperCase()]) {
                    return colorMap[hex.toUpperCase()];
                }
                
                // Find closest match
                const rgb1 = hexToRgb(hex);
                
                let minDistance = Infinity;
                let closestColor = '';
                
                for (const knownHex in colorMap) {
                    const rgb2 = hexToRgb(knownHex);
                    
                    // Calculate Euclidean distance in RGB space
                    const distance = Math.sqrt(
                        Math.pow(rgb1.r - rgb2.r, 2) +
                        Math.pow(rgb1.g - rgb2.g, 2) +
                        Math.pow(rgb1.b - rgb2.b, 2)
                    );
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestColor = colorMap[knownHex];
                    }
                }
                
                return minDistance < 60 ? `Closest: ${closestColor}` : '';
            }
            
            // 添加showNotification函数
            function showNotification(message, type) {
                notification.textContent = message;
                notification.className = 'notification ' + type;
                notification.classList.add('show');
                
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 3000);
            }
        });
    </script>
</body>
</html> 
